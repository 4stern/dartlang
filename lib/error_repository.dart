library analysis.errors;

import 'dart:async';

import 'package:logging/logging.dart';

import 'atom.dart' show Directory, File;
import 'utils.dart';
import 'analysis/analysis_server_gen.dart' show AnalysisErrors, AnalysisError,
  AnalysisFlushResults, Location;

final Logger _logger = new Logger('error_repository');

/// Repository of errors generated by `analysis.errors` events
///
/// One-stop shop for getting the status of errors the analyzer has reported.
/// Source agonostic.
class ErrorRepository implements Disposable {
  static const _empty = const [];

  /// A collection of all known errors that the analysis_server has provided us,
  /// organized by filename.
  final Map<String, List<AnalysisError>> knownErrors = {};

  final StreamSubscriptions subs = new StreamSubscriptions();

  StreamController _controller = new StreamController.broadcast();
  Stream<AnalysisErrors> _errorStream;
  Stream<AnalysisFlushResults> _flushStream;

  ErrorRepository();

  // TODO: stream a delta object like dart-tools ErrorRepository does.
  Stream get onChange => _controller.stream;

  void initStreams(Stream<AnalysisErrors> errorStream,
      Stream<AnalysisFlushResults> flushStream) {
    this._errorStream = errorStream;
    this._flushStream = flushStream;

    subs.cancel();

    subs.add(_errorStream.listen(_handleAddErrors));
    subs.add(_flushStream.listen(_handleFlushErrors));
  }

  /// Clear all known errors. This is useful for situations like when the
  /// analysis server goes down.
  void clearAll() {
    knownErrors.clear();
    _controller.add(null);
  }

  /// Clear all errors for files contained within the given directory.
  void clearForDirectory(Directory dir) {
    List<String> paths = knownErrors.keys.toList();
    for (String path in paths) {
      if (dir.contains(path)) knownErrors.remove(path);
    }
  }

  void dispose() => subs.cancel();

  void _handleAddErrors(AnalysisErrors analysisErrors) {
    // TODO: Consider consolidating all error events for a Dart project and
    // firing once analysis is complete.

    String path = analysisErrors.file;
    File file = new File.fromPath(path);
    if (file.existsSync()) {
      var oldErrors = knownErrors[path];
      var newErrors = analysisErrors.errors;

      if (oldErrors == null) oldErrors = _empty;
      if (newErrors == null) newErrors = _empty;

      knownErrors[path] = analysisErrors.errors;

      if (!_identical(oldErrors, newErrors)) {
        _controller.add(null);
      }
    } else {
      _logger.info('received an error event for a non-existent file: ${path}');
    }
  }

  void _handleFlushErrors(AnalysisFlushResults analysisFlushResults) {
    analysisFlushResults.files.forEach(knownErrors.remove);
    _controller.add(null);
  }

  static bool _identical(List<AnalysisError> a, List<AnalysisError> b) {
    if (a.length != b.length) return false;

    for (int i = 0; i < a.length; i++) {
      if (!_identicalErrors(a[i], b[i])) return false;
    }

    return true;
  }

  // TODO: Generate == operators for a whitelisted set of AS classes.

  static bool _identicalErrors(AnalysisError a, AnalysisError b) {
    if (a.severity != b.severity) return false;
    if (a.type != b.type) return false;
    if (a.message != b.message) return false;
    return _identicalLocation(a.location, b.location);
  }

  static bool _identicalLocation(Location a, Location b) {
    if (a.offset != b.offset) return false;
    if (a.length != b.length) return false;
    return a.file == b.file;
  }
}
